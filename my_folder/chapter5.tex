\chapter{Разработка сервиса интерактивного визуализатора моделей программ} \label{ch5}
В данной главе описывается разработка сервиса интерактивного визуализатора моделей программ. Для разработки сервера выбран язык программирования Java, для разработки клиента – JavaScript.
\section{Разработка сервера} \label{ch5:sec1}
Главная задача сервера – отвечать по протоколу HTTP на запросы от клиента. В нашем случае будет одна основная точка доступа, на вход которой подаётся исходный код на языке Java, а в качестве ответа ожидается JSON, в котором будет содержаться структура AST в двух видах – в облегчённом (для рисования) и в расширенном (с указанием связей с исходным кодом).
Для реализации этой логики были созданы следующие классы:
\begin{itemize}
\item Main – содержит главный метод приложения. В нём описаны точки доступа и их поведение. В том числе точка доступа для обеспечения корректной работы кросс-доменных запросов (настройка CORS), и главная точка доступа приложения для преобразования кода в AST.
\item JsonPrinter – класс для преобразования объектной структуры AST в облегчённую версию JSON. Этот класс был удалён из библиотеки JavaParser. Разработчики изменили способ сериализации, оставив только возможность генерации JSON расширенной версии AST. Расширенная версия включает в себя дополнительную информацию, в том числе номера начальных и конечных строк и столбцов для каждого узла, номера токенов, а также пустые ключи для всех синтаксически допустимых элементов, не встречающихся в коде (например, аннотаций для методов и переменных, бросаемые исключения и прочее). Поскольку облегченная версия всё-таки оказалась нужна, пришлось добавить этот класс.
\item Response – структурный класс, содержащий поля status и data. Создан для стандартизации вида ответов сервера (status может иметь значение “success” или “error”, data – любые данные). Задаёт структуру ответа сервера при сериализации в JSON.
\item AstResponse – структурный класс, содержащий поля simple и extended (для облегчённой и расширенной версии AST, соответственно). Используется в основной точке доступа как значение поля data в объекте Response при ответе.
\end{itemize}
\section{Разработка клиента} \label{ch5:sec2}
Клиент включает в себя практически всю логику приложения. Ниже описана разработка для каждой модели.
\subsection{Построение AST} \label{ch2:subsec-title-abbr}
Для построения AST нужно использовать облегчённую версию структуры, полученной от сервера. Задача сводится к преобразованию этой иерархической структуры в код графа на языке DOT. Для этого необходимо описать каждый узел дерева и каждое ребро, соединяющее узлы. Кроме того, необходимо реализовать функционал сворачивания и разворачивания поддеревьев по клику на узел.

Для получения массива узлов и массива рёбер нужно выполнить рекурсивный обход AST-структуры. В зависимости от типа полей требуется выполнять разные действия. Если тип поля – массив, нужно добавить узел с именем поля, на каждом элементе рекурсивно вызвать обход, добавляя рёбра от только что созданного узла к корневым узлам поддеревьев, созданных в каждом внутреннем обходе. Если тип поля – объект, нужно отделить поле с типом узла от остальных (значение этого поля установится как имя узла). Для всех остальных полей нужно запустить рекурсивный обход, добавляя необходимые рёбра. Если тип поля – примитив, то и название, и значение поля будут установлены в названии узла.

Для реализации функционала сворачивания и разворачивания поддеревьев необходимо каким-то образом обозначить связи между отображаемыми узлами дерева, чтобы можно было определять, является ли тот или иной узел дерева потомком другого. Это можно делать по данным из массива рёбер, но такой алгоритм будет неэффективным. Поэтому было принято решение сделать у каждого узла ссылку на родительский узел. Пройдя циклом по цепочке родительских элементов, можно понять, является ли какой-то узел потомком другого. Далее создадим множество из индексов узлов для хранения информации о корнях свёрнутых пользователем поддеревьев. При клике на узел нужно получить индекс того узла, по которому произошёл клик. Если такой индекс есть во множестве, тогда его нужно удалить из множества, а если нет, то добавить. После этого пройти по всем узлам и рёбрам, и пометить скрытыми те узлы, которые являются потомками хотя бы одного из узлов во множестве, и те рёбра, которые ведут на такие узлы (которые помечаем скрытыми).

Для создания кода графа на языке DOT достаточно создать по одной строке для каждого не скрытого узла и для каждого не скрытого ребра, а затем объединить эти строки в соответствии с синтаксисом языка DOT.

\subsection{Построение CFG} \label{ch2:subsec-title-abbr}
Для построения CFG нужно использовать расширенную версию структуры, полученной от сервера. Задача также сводится к преобразованию этих данных в код графа на языке DOT.

Входные данные – AST-дерево, описывающее код. Нужно каким-то образом определять, какие элементы будут являться узлами графа, какой текст будет в них содержаться, и какие пары из них будут соединены ориентированными рёбрами. Кроме того, узлы должны иметь разные формы, в зависимости от их типа, и некоторые рёбра должны иметь подписи “да” и “нет”, в случае если они выходят из узла-условия.

AST содержит множество типов узлов. Для удобства обхода этой структуры было решено воспользоваться адаптацией ООП-паттерна «Посетитель» (Visitor). В зависимости от типа узла, будут выполняться различные действия. В частности, необходимо описать различные действия на узлах объявления метода, объявления переменных, блоков кода, циклов while, циклов for, ветвлений if, инструкций return, break и continue. Для всех остальных типов узлов, вложенных непосредственно в перечисленные, будет создаваться отдельный узел графа, текстом для которого будет код, по которому был построен данный узел AST дерева.

Была определена процедура добавления узла. Кроме того, что она создаёт узел и добавляет его в массив узлов, она ещё ставит все необходимые рёбра в этот узел. Это реализовано за счёт создания глобального списка частично определённых рёбер (для удобства обозначим аббревиатурой ЧОР, у которых указаны начало и тип, но не указан конец). Эта процедура извлекает все значения из этого списка, добавляет в каждое ЧОР конечным узлом себя, и добавляет каждое полученное ребро в массив рёбер. Также добавляет в список ЧОР единственным элементом ЧОР, в котором началом указан новый узел, а типом – ребро без подписи. Дальнейшие инструкции (после процедуры) могут исправлять добавленное ребро.

Действия на узлах объявления метода: создание узла, добавление ЧОР. Имя узла собирается из имени метода и имён параметров метода через запятую в скобках.

Действия на узлах объявления переменных: пройти по всем объявляемым переменным. Для каждой переменной, если есть инициализирующее значение, добавляем узел процедурой. Название узла составляется из имени переменной, знака равно и кода выражения, инициализирующего переменную.

Действия на узлах блоков кода: запустить обход для каждого оператора в блоке.

Действия на узлах циклов while. Добавляется узел с помощью процедуры. Тип узла – условие, название – код условия. После этого изменяется тип пока единственного ЧОР на ребро с подписью “да”. Для корректной работы с инструкциями break и continue глобально был создан стек для циклов. Для текущего цикла создаётся объект, который будет содержать два массива ЧОР – ведущих в инструкцию break и ведущих в инструкцию continue. Этот объект добавляется в стек. Далее запускается обход тела цикла. При обходе заполняются массивы в объекте. Затем все ЧОР из массива для continue добавляются в список ЧОР. Далее во все ЧОР из списка добавляется узел условия конечным пунктом, и все они извлекаются из списка и записываются в массив рёбер. Потом в список ЧОР добавляется ЧОР из узла условия с подписью “нет”, а также все ЧОР из массива для break. Объект с массивами удаляется из стека.

Действия на узлах циклов for. Происходит всё то же самое, что с while, только вначале обходятся узлы из блока инициализации, в блоке условия может не быть кода, в этом случае будет вписано true, и после добавления всех ЧОР из массива для continue добавляется обход секции обновления переменных.

Действия на узлах ветвлений if. Добавляется узел с помощью процедуры. Тип узла – условие, название – код условия. После этого изменяется тип пока единственного ЧОР на ребро с подписью “да”. Обходом добавляется тело блока if. Затем из списка ЧОР извлекаются все ЧОР во временный список. Затем в основной список ЧОР добавляется ЧОР из узла с условием с подписью “нет”. Если у конструкции присутствует блок else, обходом добавляется его тело. После этого в любом случае все ЧОР из временного списка добавляются обратно в основной.

Действия на узлах инструкций return. Добавляется узел с помощью процедуры. Тип узла – return, название – return и код выражения под оператором return. После добавления узла очищается список ЧОР.

Действия на узлах инструкций break. Получаем массив для break из верхнего элемента стека. В него извлекаем все ЧОР из списка ЧОР.

Действия на узлах инструкций continue. Аналогично break, только с массивом для continue.

Действия на узлах остальных типов, вложенных непосредственно в узлы описанных выше типов. Добавляется узел с помощью процедуры. Тип – обычный, название – код узла из AST.

Нужно запустить обход от корня AST дерева. Этот обход сформирует массивы из узлов и рёбер для отрисовки.

При отрисовке нужно узлы с типами объявление метода и return рисовать овалами, узлы-условия ромбами, а обычные – прямоугольниками.

\subsection{Построение DDG и PDG} \label{ch2:subsec-title-abbr}

Для построения DDG и PDG тоже используется расширенная версия AST, полученная от сервера. Узлы и рёбра можно получить по тому же алгоритму, который использовался для построения CFG с небольшим дополнением. В каждый узел нужно вставить ссылку на элемент исходного AST. Это необходимо для определения переменных, которые были считаны и записаны в этом узле. Дополнительно нужно сформировать массив рёбер, соединяющих узлы, в которых происходит запись значений переменных, с узлами, в которых происходит возможное чтение этих значений. Назовём его массивом зависимостей.

Чтобы сформировать массив зависимостей, нужно у каждого узла составить множество имен переменных, которые в нём получают новые значения, и множество переменных, которые читаются в этом узле.

Для составления множества читаемых переменных по данному узлу, нужно сделать обход элемента AST, соответствующего узлу. Для такого обхода будем использовать подход, аналогичный использованному при построении CFG (с применением адаптации паттерна Visitor), только типы узлов и действия будут отличаться. В данном случае нужно обрабатывать все типы узлов, которые могут внутри себя иметь чтение переменных. Во всех таких узлах нужно запускать обходы на тех частях, где возможно чтение переменных. В итоге при попадании в узел с типом имя переменной, нужно добавить имя во множество. Аналогично можно действовать для получения множества записываемых переменных для каждого узла.

Теперь нужно для каждого узла составить набор из переменных, доступных узлу (которым присвоено значение в цепочке до него), и для каждой такой переменной сделать множество из возможных источников значения этой переменной. Это можно сделать алгоритмом, похожим на рекурсивный обход графа в глубину от первого узла. Таким образом в графе будут пройдены все возможные пути, в том числе циклы. И на каждый шаг каждого пути будет передаваться объект контекста, ключами которого будут все записанные переменные, а значениями узлы, на которых произошла последняя запись. При попадании на узел во множества источников добавляются все источники из контекста. Если никаких изменений не произошло (все источники ранее уже были добавлены), и все соседние узлы посещены, то это сигнал к завершению рекурсии.

Используя построенные наборы, можно теперь составить массив зависимостей. Для этого нужно пройти по каждому узлу. В каждом узле по всем считанным переменным. Для каждой переменной перебрать множество источников. В зависимости нужно добавить ребро между источником и текущим узлом.

Отрисовка будет работать аналогично CFG, только для DDG нужно скрыть рёбра из CFG, а для PDG не нужно. После этого нужно добавить рёбра из зависимостей пунктирными стрелками, не меняющими положение узлов (чтобы узлы располагались аналогично CFG).

\subsection{Построение ASG} \label{ch2:subsec-title-abbr}

При построении ASG используется облегчённая версия структуры, полученной от сервера. Теперь к AST нужно добавить рёбра от узлов объявления переменных к узлам, где они используются. И ещё рёбра последовательности инструкций, как в CFG.

Для получения узлов и рёбер можно использовать алгоритм, реализованный для отрисовки AST. Только теперь для каждого узла, созданного из объекта, нужно добавить ссылку на этот объект.

Для получения рёбер последовательности инструкций можно использовать алгоритм, аналогичный CFG. Только в алгоритме построения CFG узлы графа создавались при обходе, а теперь необходимо использовать узлы, созданные алгоритмом построения AST. Соответствие по узлам можно установить, опираясь на добавленные ссылки в узлах AST. Чтобы это было проще, можно сделать map, в котором ключами будут объекты исходной структуры, а значениями индексы узлов AST, которым они соответствуют. Для этого достаточно сделать один проход по массиву узлов AST, поскольку в каждом таком узле содержится ссылка на исходный объект.

Для получения рёбер, соединяющих узлы с объявлением переменных с узлами с использованием переменных, нужно для каждой объявленной переменной получить индекс узла с её объявлением, и индексы узлов с её использованием. Объекты с именами переменных в исходной структуре имеют определённый тип. По этому типу можно найти все упоминания переменных. Чтобы понять, является это упоминание объявлением или использованием, нужно посмотреть на тип родительского элемента этого объекта. Если родительский элемент имеет тип объявление переменной или параметр метода, упоминание считается объявлением, в противном случае использованием. Теперь достаточно для каждого найденного объявления переменной добавить по одному ребру к каждому использованию.

При отрисовке ребра между соседними инструкциями для наглядности обозначаются красными пунктирными стрелками, а рёбра между объявлениями и использованием переменных пунктирными синими.

\subsection{Построение SSA} \label{ch2:subsec-title-abbr}

При построении SSA используется расширенная версия структуры, полученной от сервера. Для получения узлов и рёбер графа можно использовать алгоритм, аналогичный CFG. Только теперь названия узлов не указываются на этапе создания узлов. Они будут добавлены позже. После этого нужно добавить в каждый узел информацию о считанных и записанных переменных в этом узле, аналогично DDG и PDG. Далее нужно установить версии для объявлений и использований каждой переменной.

Сложность заключается в том, что значения переменных могут устанавливаться в разных ветвях программы, и затем, когда ветви сходятся, по правилам построения SSA, необходимо добавить узел для каждой переменной, которая имеет разные версии на сходящихся ветвях. В этом узле нужно обозначить новую версию переменной, в которую записывается результат вызова Фи-функции, аргументами которой передаются все версии переменной на сходящихся ветвях. Кроме того, нумерация версий переменных должна происходить в порядке появления в коде, но с учётом добавленных Фи-определений.

Для начала нужно определить узлы, в которых сходятся несколько ветвей программы. Для этого достаточно посчитать для каждого узла, в скольких рёбрах он является конечным. Если количество рёбер больше одного, то перед этим узлом могут появиться Фи-определения. Назовём такой узел узлом схождения.

Для установки версий переменных можно воспользоваться алгоритмом, аналогичным рекурсивному обходу графа в глубину от первого узла. Таким образом в графе будут пройдены все возможные пути, в том числе циклы. В каждый рекурсивный вызов будет передаваться узел, на который попадаем, а также индекс узла, из которого попадаем в этот узел. При попадании в какой-либо узел, нужно определить контекст переменных, который приходит от предыдущего узла (какие переменные существуют, и какие их версии передаются). Контекст будет кэшироваться в каждом узле. Изначально у всех узлов зададим пустой контекст. При попадании на узел, входной контекст будет определяться как закэшированный контекст прошлого узла, на который накладываются версии записанных в том узле переменных. При попадании на узел схождения, для каждой переменной нужно проверить, отличается ли версия в закэшированном контексте от версии во входном контексте. В случае, если не отличается, ничего делать не надо. В противном случае нужно сравнить версию этой переменной с той, которая была прислана в прошлый раз с этого же узла. Если это первый вход с этого узла, либо если версии отличаются, это сигнал к продолжению рекурсии, в противном случае к выходу из рекурсии. Далее, если количество различных версий переменной среди последних пришедших по каждой из ветвей равно единице, то достаточно переопределить версию переменной в закэшированном контексте на единственную полученную. В противном случае, если ранее это не было сделано, в закэшированном контексте необходимо установить новую версию для данной переменной. При попадании на узел, не являющийся узлом схождения, достаточно обновить закэшированный контекст на входной (переписать все версии из входного контекста в закэшированный). Такие узлы всегда продолжают рекурсию. Затем, вне зависимости от типа узла, если в нём присутствуют записи в переменные, и при этом узел ранее не был посещён, для каждой записываемой переменной создаём новую версию и сохраняем их в отдельный объект, который будет содержать версии всех записанных в узле переменных. Далее, если рекурсию нужно продолжать, функция запускается на всех узлах, в которые можно перейти из текущего. После этого обхода в каждом узле будет храниться информация о версиях используемых переменных, но пока эти версии будут стоять в неправильном порядке, поскольку устанавливались в порядке обхода в глубину, а не в порядке следования в коде.

Далее, чтобы исправить порядок версий, нужно пройти по узлам в порядке следования в коде. При проходе нужно смотреть на порядок первых упоминаний версий переменных в закэшированных контекстах узлов и объектах с версиями записываемых переменных. Таким образом, для каждой переменной получится порядок упоминания её версий в коде, который может отличаться от естественного. Нужно поставить в соответствие каждой такой версии номер её упоминания, и исправить в закэшированных контекстах и объектах с версиями записываемых переменных версии на номера их упоминаний.

Далее сложность заключается в том, что теперь каким-то образом нужно вставить версии переменных в названия узлов при отрисовке. При построении CFG и ему подобных графов для названий узлов использовался непосредственно исходный код. Он извлекался с помощью координат, указанных в каждом объекте структуры, полученной с сервера (указаны номер начальной строки, номер конечной строки, номер столбца в начальной строке и номер столбца в конечной строке). По этим данным можно было извлечь необходимый участок кода. Теперь так сделать не получится, поскольку в исходном коде версии переменных не указаны. Чтобы это исправить, исходный код был преобразован в матрицу из строк по одному символу. Далее необходимо было пройти по всем узлам, и для каждой записанной переменной из узла в матрицу к последнему символу имени переменной дописать версию. Аналогично для чтения переменных. Таким образом, ранее описанные координаты будут определять участки матрицы, а не исходного кода, а в матрице некоторые элементы станут длиной более одного символа, что не влияет на нумерацию строк и столбцов. Теперь достаточно написать функцию, которая сможет по координатам взять участок матрицы и собрать из него строку, в которой уже будут присутствовать версии переменных. Когда это готово, можно пройти по каждому узлу и добавить название. Для некоторых типов узлов логика построения названия будет отличаться от CFG. Например, присваивания с коротким синтаксисом (с использованием операторов +=, -=, *= и т. п.), инкремент и декремент нужно записать в ином виде, нежели в коде, поскольку они и записывают, и читают переменную, причем разные её версии.

При отрисовке узлов схождения для каждой переменной, у которой в итоге с разных ветвей идут разные версии, необходимо добавить узел с Фи-функцией. Это также меняет рёбра. Все рёбра, которые шли в этот узел схождения, должны идти в первый Фи-узел. Остальные Фи-узлы, если они есть, выстраиваются в цепочку за первым, и от последнего Фи-узла ребро должно идти к исходному узлу схождения. В остальном логика отрисовки аналогична CFG.

\section{Выводы по главе} \label{ch5:sec3}
В данной главе были описаны общие детали реализации интерактивного визуализатора моделей программ, такие как структура сервера и процесс построения абстрактного синтаксического дерева, графа потока управления, графа зависимости по данным, графа зависимости программы, абстрактного семантического графа и представления на основе статического однократного присваивания.
\newpage